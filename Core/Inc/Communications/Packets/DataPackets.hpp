#pragma once
#include "ST-LIB.hpp"

/*Data packets for PCU 
-AUTOGENERATED CODE, DO NOT MODIFY-*/
class DataPackets{
public:
    enum class general_state_machine : uint8_t 
    {
        Connecting = 0,
        Operational = 1,
        Fault = 2,
    };
    enum class operational_state_machine : uint8_t 
    {
        IDLE = 0,
        Accelerating = 1,
    };
    enum class space_vector_active : uint8_t 
    {
        DISABLE = 0,
        ACTIVE = 1,
    };
    enum class current_control_active : uint8_t 
    {
        DISABLE = 0,
        ACTIVE = 1,
    };
    enum class speed_control_active : uint8_t 
    {
        DISABLE = 0,
        ACTIVE = 1,
    };
    enum class encoder_direction : uint8_t 
    {
        Forward = 0,
        Backward = 1,
    };
    
    
    static void pwm_packet_init(uint32_t &frequency, float &modulation_frequency, float &duty_u, float &duty_v, float &duty_w)
    {
        pwm_packet_packet = new HeapPacket(static_cast<uint16_t>(550), &frequency, &modulation_frequency, &duty_u, &duty_v, &duty_w);
    }
    
    static void Batteries_Voltage_init(float &Voltage_Battery_A, float &Voltage_Battery_B)
    {
        Batteries_Voltage_packet = new HeapPacket(static_cast<uint16_t>(551), &Voltage_Battery_A, &Voltage_Battery_B);
    }
    
    static void Current_sensors_init(float &current_sensor_u_a, float &current_sensor_v_a, float &current_sensor_w_a, float &current_sensor_u_b, float &current_sensor_v_b, float &current_sensor_w_b, double &current_Peak, double &Error_PI, double &Target_Voltage, float &SVPWM_Time, float &imod)
    {
        Current_sensors_packet = new HeapPacket(static_cast<uint16_t>(552), &current_sensor_u_a, &current_sensor_v_a, &current_sensor_w_a, &current_sensor_u_b, &current_sensor_v_b, &current_sensor_w_b, &current_Peak, &Error_PI, &Target_Voltage, &SVPWM_Time, &imod);
    }
    
    static void StateMachine_states_init(general_state_machine &general_state_machine, operational_state_machine &operational_state_machine, space_vector_active &space_vector_active, current_control_active &current_control_active, speed_control_active &speed_control_active)
    {
        StateMachine_states_packet = new HeapPacket(static_cast<uint16_t>(553), &general_state_machine, &operational_state_machine, &space_vector_active, &current_control_active, &speed_control_active);
    }
    
    static void Speetec_data_init(double &encoder_position, encoder_direction &encoder_direction, double &encoder_speed, double &encoder_speed_km_h, double &encoder_acceleration)
    {
        Speetec_data_packet = new HeapPacket(static_cast<uint16_t>(554), &encoder_position, &encoder_direction, &encoder_speed, &encoder_speed_km_h, &encoder_acceleration);
    }
    
    static void Speed_data_init(float &target_speed, double &speed_error, float &actual_current_ref)
    {
        Speed_data_packet = new HeapPacket(static_cast<uint16_t>(555), &target_speed, &speed_error, &actual_current_ref);
    }
    
    static void GateDriverReporting_init(bool &gd_fault_a, bool &gd_fault_b, bool &gd_ready_a, bool &gd_ready_b)
    {
        GateDriverReporting_packet = new HeapPacket(static_cast<uint16_t>(558), &gd_fault_a, &gd_fault_b, &gd_ready_a, &gd_ready_b);
    }
    
    public:
    inline static HeapPacket *pwm_packet_packet{nullptr};
    inline static HeapPacket *Batteries_Voltage_packet{nullptr};
    inline static HeapPacket *Current_sensors_packet{nullptr};
    inline static HeapPacket *StateMachine_states_packet{nullptr};
    inline static HeapPacket *Speetec_data_packet{nullptr};
    inline static HeapPacket *Speed_data_packet{nullptr};
    inline static HeapPacket *GateDriverReporting_packet{nullptr};
    
    inline static DatagramSocket *control_station_udp{nullptr};
    
        
    static void start()
    {   
        if (pwm_packet_packet == nullptr) {
            ErrorHandler("Packet pwm_packet not initialized");
        }
        if (Batteries_Voltage_packet == nullptr) {
            ErrorHandler("Packet Batteries_Voltage not initialized");
        }
        if (Current_sensors_packet == nullptr) {
            ErrorHandler("Packet Current_sensors not initialized");
        }
        if (StateMachine_states_packet == nullptr) {
            ErrorHandler("Packet StateMachine_states not initialized");
        }
        if (Speetec_data_packet == nullptr) {
            ErrorHandler("Packet Speetec_data not initialized");
        }
        if (Speed_data_packet == nullptr) {
            ErrorHandler("Packet Speed_data not initialized");
        }
        if (GateDriverReporting_packet == nullptr) {
            ErrorHandler("Packet GateDriverReporting not initialized");
        }
        

        control_station_udp = new DatagramSocket("192.168.1.5",50400,"192.168.0.9",50400);
        
        Scheduler::register_task(16670, +[](){
            DataPackets::control_station_udp->send_packet(*DataPackets::pwm_packet_packet);
            DataPackets::control_station_udp->send_packet(*DataPackets::Batteries_Voltage_packet);
            DataPackets::control_station_udp->send_packet(*DataPackets::Current_sensors_packet);
            DataPackets::control_station_udp->send_packet(*DataPackets::StateMachine_states_packet);
            DataPackets::control_station_udp->send_packet(*DataPackets::Speetec_data_packet);
            DataPackets::control_station_udp->send_packet(*DataPackets::Speed_data_packet);
            DataPackets::control_station_udp->send_packet(*DataPackets::GateDriverReporting_packet);
            });
    }


   
};